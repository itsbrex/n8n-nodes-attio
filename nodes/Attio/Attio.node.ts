import {
	IExecuteFunctions,
	INodeExecutionData,
	INodeType,
	INodeTypeDescription,
	NodeConnectionType,
	NodeOperationError,
} from 'n8n-workflow';
import {
	N8NPropertiesBuilder,
	N8NPropertiesBuilderConfig,
} from '@devlikeapro/n8n-openapi-node';
import * as doc from './openapi.json';

const config: N8NPropertiesBuilderConfig = {};
const parser = new N8NPropertiesBuilder(doc, config);
const properties = parser.build();

// Fix the displayOptions issue: map operation names to values
const operationMapping: { [key: string]: string } = {};

// Build the mapping by finding all operation properties
properties.forEach((prop: any) => {
	if (prop.name === 'operation' && prop.options) {
		prop.options.forEach((opt: any) => {
			operationMapping[opt.name] = opt.value;
		});
	}
});

// Fix displayOptions in all properties to use operation values instead of names
const fixedProperties = properties.map((prop: any) => {
	if (prop.displayOptions?.show?.operation) {
		return {
			...prop,
			displayOptions: {
				...prop.displayOptions,
				show: {
					...prop.displayOptions.show,
					operation: prop.displayOptions.show.operation.map((opName: string) =>
						operationMapping[opName] || opName
					),
				},
			},
		};
	}
	return prop;
});

export class Attio implements INodeType {
	description: INodeTypeDescription = {
		displayName: 'Attio',
		name: 'attio',
		icon: 'file:attio.svg',
		group: ['transform'],
		version: 1,
		subtitle: '={{$parameter["operation"] + ": " + $parameter["resource"]}}',
		description: 'Interact with Attio API',
		defaults: {
			name: 'Attio',
		},
		inputs: [NodeConnectionType.Main],
		outputs: [NodeConnectionType.Main],
		credentials: [
			{
				name: 'attioApi',
				required: true,
			},
		],
		requestDefaults: {
			headers: {
				Accept: 'application/json',
				'Content-Type': 'application/json',
			},
		},
		properties: fixedProperties, // Use the fixed properties
	};

	async execute(this: IExecuteFunctions): Promise<INodeExecutionData[][]> {
		const items = this.getInputData();
		const returnData: INodeExecutionData[] = [];
		const credentials = await this.getCredentials('attioApi');

		for (let i = 0; i < items.length; i++) {
			try {
				const resource = this.getNodeParameter('resource', i) as string;
				const operation = this.getNodeParameter('operation', i) as string;

				// Find the operation configuration
				const operationProperty: any = properties.find(
					(prop: any) => prop.name === 'operation' &&
					prop.displayOptions?.show?.resource?.[0] === resource &&
					prop.options?.find((opt: any) => opt.value === operation)
				);

				if (!operationProperty || !operationProperty.options) {
					throw new NodeOperationError(this.getNode(), `Operation ${operation} not found for resource ${resource}`);
				}

				const operationConfig = operationProperty.options.find((opt: any) => opt.value === operation);
				if (!operationConfig || !operationConfig.routing?.request) {
					throw new NodeOperationError(this.getNode(), `Operation configuration not found for ${operation}`);
				}

				let { method, url } = operationConfig.routing.request;

				// Fix: Remove leading '=' from URLs generated by n8n-openapi-node
				if (url && url.startsWith('=')) {
					url = url.substring(1);
				}

				// Build the request
				const requestOptions: any = {
					method,
					url,
					headers: {
						'Authorization': `Bearer ${credentials.accessToken}`,
						'Accept': 'application/json',
						'Content-Type': 'application/json',
					},
					json: true,
					// Don't initialize qs here - only add it if we have actual query parameters
				};

				// Process parameters based on their routing configuration
				const allProperties = properties.filter((prop: any) => {
					return prop.displayOptions?.show?.operation?.[0] === operation &&
						prop.displayOptions?.show?.resource?.[0] === resource;
				});

				for (const prop of allProperties) {
					const propAny = prop as any;
					if (propAny.name === 'operation' || propAny.type === 'notice') continue;

					try {
						const value = this.getNodeParameter(propAny.name, i, propAny.default);

						if (value !== undefined && value !== null && value !== '') {
							// Handle routing based on property configuration
							if (propAny.routing?.send) {
								const { type, property, value: valueExpression } = propAny.routing.send;

								// Evaluate the value expression if present
								let processedValue = value;
								if (valueExpression && typeof value === 'string') {
									try {
										// For JSON fields, parse them
										if (propAny.type === 'json') {
											processedValue = JSON.parse(value);
										}
									} catch (e) {
										// If parsing fails, use the raw value
									}
								}

								switch (type) {
									case 'body':
										if (!requestOptions.body) requestOptions.body = {};
										requestOptions.body[property] = processedValue;
										break;
									case 'query':
										// Only add query parameters if they have actual values
										if (processedValue !== undefined && processedValue !== null && processedValue !== '') {
											if (!requestOptions.qs) requestOptions.qs = {};
											requestOptions.qs[property] = processedValue;
										}
										break;
								}
							}
						}
					} catch (error) {
						// Parameter is optional and not set
					}
				}

				// Replace path parameters in URL
				// Handle both {param} and {{$parameter["param"]}} formats
				let finalUrl = requestOptions.url;

				// First handle {{$parameter["paramName"]}} format (generated by n8n-openapi-node)
				const n8nParamMatches = finalUrl.match(/\{\{\$parameter\["([^"]+)"\]\}\}/g);
				if (n8nParamMatches) {
					for (const match of n8nParamMatches) {
						const paramName = match.match(/\{\{\$parameter\["([^"]+)"\]\}\}/)?.[1];
						if (paramName) {
							try {
								const paramValue = this.getNodeParameter(paramName, i);
								if (paramValue !== undefined && paramValue !== null) {
									finalUrl = finalUrl.replace(match, String(paramValue));
								}
							} catch (error) {
								// Parameter might not exist or is optional
							}
						}
					}
				}

				// Also handle simple {param} format just in case
				const simpleParamMatches = finalUrl.match(/\{([^}]+)\}/g);
				if (simpleParamMatches) {
					for (const match of simpleParamMatches) {
						const paramName = match.replace(/[{}]/g, '');
						try {
							const paramValue = this.getNodeParameter(paramName, i);
							if (paramValue !== undefined && paramValue !== null) {
								finalUrl = finalUrl.replace(match, String(paramValue));
							}
						} catch (error) {
							// Parameter might not exist or is optional
						}
					}
				}

				// Ensure the URL is absolute
				if (!finalUrl.startsWith('http')) {
					finalUrl = 'https://api.attio.com' + finalUrl;
				}

				requestOptions.url = finalUrl;

				// Clean up empty query string object to prevent trailing =
				if (requestOptions.qs && Object.keys(requestOptions.qs).length === 0) {
					delete requestOptions.qs;
				}

				// Ensure we're not passing undefined values that might cause issues
				const cleanRequestOptions: any = {
					method: requestOptions.method,
					url: requestOptions.url,
					headers: requestOptions.headers,
					json: requestOptions.json,
				};

				// Only add body if it exists and has content
				if (requestOptions.body && Object.keys(requestOptions.body).length > 0) {
					cleanRequestOptions.body = requestOptions.body;
				}

				// Only add qs if it exists and has content
				if (requestOptions.qs && Object.keys(requestOptions.qs).length > 0) {
					cleanRequestOptions.qs = requestOptions.qs;
				}

				// Make the API request
				const response = await this.helpers.request(cleanRequestOptions);

				returnData.push({
					json: response,
					pairedItem: { item: i },
				});

			} catch (error) {
				if (this.continueOnFail()) {
					returnData.push({
						json: {
							error: error.message,
						},
						pairedItem: { item: i },
					});
					continue;
				}
				throw error;
			}
		}

		return [returnData];
	}
}
